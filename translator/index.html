<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>30 秒面试 | Language Crack</title>
    <meta name="description" content="外语学习知识手册">
    
    
    <link rel="preload" href="/language-learning/assets/css/0.styles.c12aa871.css" as="style"><link rel="preload" href="/language-learning/assets/js/app.18b27bb5.js" as="script"><link rel="preload" href="/language-learning/assets/js/12.aae45531.js" as="script"><link rel="prefetch" href="/language-learning/assets/js/2.cda51ec0.js"><link rel="prefetch" href="/language-learning/assets/js/3.2b4c7406.js"><link rel="prefetch" href="/language-learning/assets/js/4.b3090267.js"><link rel="prefetch" href="/language-learning/assets/js/5.4a08bf14.js"><link rel="prefetch" href="/language-learning/assets/js/6.2807e9a7.js"><link rel="prefetch" href="/language-learning/assets/js/7.ae66b14c.js"><link rel="prefetch" href="/language-learning/assets/js/8.9d553532.js"><link rel="prefetch" href="/language-learning/assets/js/9.59c4f144.js"><link rel="prefetch" href="/language-learning/assets/js/10.88ed96a6.js"><link rel="prefetch" href="/language-learning/assets/js/11.78ad6500.js"><link rel="prefetch" href="/language-learning/assets/js/13.771ec1c6.js"><link rel="prefetch" href="/language-learning/assets/js/14.d87a3abb.js"><link rel="prefetch" href="/language-learning/assets/js/15.e8ba9c34.js">
    <link rel="stylesheet" href="/language-learning/assets/css/0.styles.c12aa871.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/language-learning/" class="home-link router-link-active"><!----> <span class="site-name">Language Crack</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/language-learning/english/" class="nav-link">英语</a></div><div class="nav-item"><a href="/language-learning/japanese/" class="nav-link">日语</a></div><div class="nav-item"><a href="/language-learning/translator/" class="nav-link router-link-exact-active router-link-active">翻译练习</a></div><div class="nav-item"><a href="https://github/Jecyu/language-learning" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://byoungd.gitbooks.io/english-level-up-tips-for-chinese/content/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  English-level-up-tips-for-Chinese
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/language-learning/english/" class="nav-link">英语</a></div><div class="nav-item"><a href="/language-learning/japanese/" class="nav-link">日语</a></div><div class="nav-item"><a href="/language-learning/translator/" class="nav-link router-link-exact-active router-link-active">翻译练习</a></div><div class="nav-item"><a href="https://github/Jecyu/language-learning" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://byoungd.gitbooks.io/english-level-up-tips-for-chinese/content/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  English-level-up-tips-for-Chinese
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>翻译练习</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/language-learning/translator/" class="active sidebar-link">30 秒面试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/language-learning/translator/#html" class="sidebar-link">HTML</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/language-learning/translator/#img-图片标签上-的alt-属性的作用是什么？easy" class="sidebar-link">img 图片标签上 的alt 属性的作用是什么？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#缓存清除的目的是什么，如何实现？easy" class="sidebar-link">缓存清除的目的是什么，如何实现？</a></li></ul></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#css" class="sidebar-link">CSS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/language-learning/translator/#css-bem-是什么？easy" class="sidebar-link">CSS BEM 是什么？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#使用-css-预处理器的优点是什么？easy" class="sidebar-link">使用 CSS 预处理器的优点是什么？</a></li></ul></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#javascript" class="sidebar-link">JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/language-learning/translator/#等号运算符-和-有什么区别呢？easy" class="sidebar-link">等号运算符 == 和 === 有什么区别呢？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#react-的元素和组件有什么区别？easy" class="sidebar-link">React 的元素和组件有什么区别？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#后缀增量运算符-i-和-前缀增量运算符-i-有什么区别？easy" class="sidebar-link">后缀增量运算符 i++ 和 前缀增量运算符++i 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#promise-可以处于几种状态？easy" class="sidebar-link">Promise 可以处于几种状态？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#在-react-中，什么是一个有状态的组件？easy" class="sidebar-link">在 React 中，什么是一个有状态的组件？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#什么是一个无状态的组件easy" class="sidebar-link">什么是一个无状态的组件</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#创建一个批处理函数，它返回该批中的能够按照食谱进行烹饪的最多次数。intermediate" class="sidebar-link">创建一个批处理函数，它返回该批中的能够按照食谱进行烹饪的最多次数。</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#创建一个功能上相当于方法function-prototype-bind的单例函数-bindintermediate" class="sidebar-link">创建一个功能上相当于方法Function.prototype.bind的单例函数 bind&lt;sup style=&quot;color: green;&quot;&gt;INTERMEDIATE</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#回调函数作为setstate-的一个参数的目的是什么？" class="sidebar-link">回调函数作为setState 的一个参数的目的是什么？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#什么是回调？你可以举一个例子来说明吗？" class="sidebar-link">什么是回调？你可以举一个例子来说明吗？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#在-javascript-中，你是怎么拷贝一个对象的？intermediate" class="sidebar-link">在 JavaScript 中，你是怎么拷贝一个对象的？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#在-javascript-中你是怎么比较两个对象是否相等？intermediate" class="sidebar-link">在 JavaScript 中你是怎么比较两个对象是否相等？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#什么是-cors？intermediate" class="sidebar-link">什么是 CORS？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#dom-是什么-？" class="sidebar-link">DOM 是什么 ？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#事件委托是什么，为什么它是有用的呢？你可以用一个例子来说明怎么用吗？intermediate" class="sidebar-link">事件委托是什么，为什么它是有用的呢？你可以用一个例子来说明怎么用吗？</a></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#javascript-中的表达式和声明之间有什么区别？intermediate" class="sidebar-link">JavaScript 中的表达式和声明之间有什么区别？</a></li></ul></li><li class="sidebar-sub-header"><a href="/language-learning/translator/#参考资料" class="sidebar-link">参考资料</a></li></ul></li><li><a href="/language-learning/translator/skill.html" class="sidebar-link">翻译技巧</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="_30-秒面试"><a href="#_30-秒面试" aria-hidden="true" class="header-anchor">#</a> 30 秒面试</h1> <blockquote><p>原文来自：<a href="https://30secondsofinterviews.org/" target="_blank" rel="noopener noreferrer">https://30secondsofinterviews.org/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、</p></blockquote> <h2 id="html"><a href="#html" aria-hidden="true" class="header-anchor">#</a> HTML</h2> <h3 id="img-图片标签上-的alt-属性的作用是什么？easy"><a href="#img-图片标签上-的alt-属性的作用是什么？easy" aria-hidden="true" class="header-anchor">#</a> img 图片标签上 的<code>alt</code> 属性的作用是什么？<sup style="color: green;">Easy</sup></h3> <p>如果用户无法查看图像时，则<code>alt</code> 属性提供图像的替代信息。
<code>alt</code> 属性应该用来描述除了那些仅用于装饰目的图像之外的任何图像
，在这种情况下，图片的 <code>alt</code> 属性值应该留空。</p> <p>面试官想听到的：</p> <ul><li>装饰图像应该拥有一个空的 <code>alt</code> 属性。</li> <li>Web 爬虫使用<code>alt</code> 标签来理解图像内容，所以它们被认为对搜索引擎（SEO）优化很重要。</li> <li>把 <code>.</code> 放在 <code>alt</code> 标签末尾来提供网站的可访问性。</li></ul> <h3 id="缓存清除的目的是什么，如何实现？easy"><a href="#缓存清除的目的是什么，如何实现？easy" aria-hidden="true" class="header-anchor">#</a> 缓存清除的目的是什么，如何实现？<sup style="color: green;">Easy</sup></h3> <p>浏览器具有用于将网站文件临时存储的缓存，因此在页面切换之间相同的页面时不需要重新下载。
服务器通过设置发送响应头告诉浏览在给予的时间内存储文件。这大大提升了网站的速度和保留了带宽。</p> <p>然而，当开发者已经更改网站内容时，它可能会导致问题，因为用户的缓存仍然引用旧的文件。如果缓存的 CSS 和 JavaScript 文件引用的元素已经不存在、已经移动或者重命名，则会使它们保留旧的功能或者破坏网站。</p> <p>清除缓存是一种强制浏览器下载新文件的过程。这是通过将文件命名为与旧文件不同的名字来实现的。</p> <p>强制浏览器重新下载文件的一种技术在文件的末尾附加一个查询字符串。</p> <ul><li><code>src=&quot;js/script.js&quot;</code> =&gt; <code>scr=&quot;js/script.js?v=2&quot;</code></li></ul> <p>这样浏览器认为它是不同的文件，但不需要更改文件名。</p> <h2 id="css"><a href="#css" aria-hidden="true" class="header-anchor">#</a> CSS</h2> <h3 id="css-bem-是什么？easy"><a href="#css-bem-是什么？easy" aria-hidden="true" class="header-anchor">#</a> CSS BEM 是什么？<sup style="color: green;">Easy</sup></h3> <p>BEM 方法是 一种 CSS 类的命名约定，旨在通过定义命名空间解决作用域问题来使 CSS代码 更具可维护性。BEM 主张块级元素修饰符，这是对自身结构的解释。

块就是一个独立组件，可在项目中重复利用，它充当子组件（元素）的“命名空间”。

当块或元素处于一种特定状态或者是结构或样式不同时，修饰符用作标记。
</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token comment">/* block component */</span>
<span class="token selector">.block</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">/* element */</span>
<span class="token selector">.block__element</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">/* modifier */</span>
<span class="token selector">.block__element--modifier</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里有一个在标签上使用类名的例子：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>navbar<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>navbar__link navbar__link--active<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>navbar__link<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>navbar__link<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>在这个例子中，<code>navbar</code> 是一个块，<code>navbar__link</code> 是一个元素，离开 <code>navbar</code> 组件是没有意义的。<code>navbar__link--active</code> 则是一个修饰符用来表明 <code>navbar__link</code> 元素的不同状态。</p> <p>因为修饰符是冗余的，更多选择是使用 <code>is-*</code> 标记来替代修饰符。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>/<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>navbar_link is-active<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>这些必须链接到元素的末尾，不应该单独使用，否则会导致作用域问题。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">.navbar__link.is-active</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>面试官想听到的：</p> <ul><li>替代的解决作用域问题的方案类似 CSS-in-JS，<a href="https://github.com/tuchk4/awesome-css-in-js/blob/master/README-ZH_CN.md" target="_blank" rel="noopener noreferrer">awesome-css-in-js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>其他的方案（Vue的 scoped css）、css modules</li> <li>扩展：<a href="https://juejin.im/post/5c25de5f6fb9a04a053fbf53" target="_blank" rel="noopener noreferrer">css 命名：BEM, scoped css, css modules 与 css-in-js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="使用-css-预处理器的优点是什么？easy"><a href="#使用-css-预处理器的优点是什么？easy" aria-hidden="true" class="header-anchor">#</a> 使用 CSS 预处理器的优点是什么？<sup style="color: green;">Easy</sup></h3> <p>CSS 预处理器添加了原生 CSS 不具有的实用功能，并且总体上通过 DRY（不要重复你自己）原则让 CSS 代码更加整洁和更具可维护性。
它们对于嵌套选择器的简洁减少了重复代码。
它们为实现一致的主题（然而，CSS 变量已经很大程度上取代了这个功能）提供了变量和额外的工具如颜色函数（<code>lighten</code>， <code>darken</code>，<code>transparenntize</code>，等等）、mixins，loop等其他工具，这些工具让CSS更像是一种真正的编程语言，并为开发人员提供了生成复杂 CSS 的更多能力。
</p> <p>面试官想听到的：</p> <ul><li>它们允许我们写出更具可维护性和可扩展性的 CSS 代码。</li> <li>使用 CSS 处理器的一些缺点（配置，重新编译的时间可能会变慢，等等）。</li></ul> <h2 id="javascript"><a href="#javascript" aria-hidden="true" class="header-anchor">#</a> JavaScript</h2> <h3 id="等号运算符-和-有什么区别呢？easy"><a href="#等号运算符-和-有什么区别呢？easy" aria-hidden="true" class="header-anchor">#</a> 等号运算符 <code>==</code> 和 <code>===</code> 有什么区别呢？<sup style="color: green;">Easy</sup></h3> <p>三重等号（===）检查是严格相等，意味着符号两边变量的类型和值都必须相同。
双重等号（==）会进行类型的强制转换，因此两个变量的类型都相同后再进行严格的比较。</p> <p>面试官想听到的：</p> <ul><li>无论什么时候，我们都应该使用三重等号比较两个变量是否相等，因为双重等号会有不直观的结果。</li> <li>提及下 <code>falsy</code> 值的比较，如 0 和 false。</li></ul> <h3 id="react-的元素和组件有什么区别？easy"><a href="#react-的元素和组件有什么区别？easy" aria-hidden="true" class="header-anchor">#</a> React 的元素和组件有什么区别？<sup style="color: green;">Easy</sup></h3> <p>一个元素是一个纯 JavaScript 对象，用来描述一个 DOM 节点或者一个组件。元素是干净的，从来不会被改变，并且很容易创建。</p> <p>一个组件就是一个函数或者一个类。组件可以拥有自己的状态 state，以及提供 props 作为输入，并且输出一颗元素树（但是它们可以作为一个普通容器或包裹，而且不需要输出 dom 节点）。组件在初始化生命周期方法时具有副作用（例如，AJAX 请求，DOM 操作，引入第三方库的接口）并且创造成本比较高。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Component</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&quot;Hello&quot;</span>
<span class="token keyword">const</span> componentElement <span class="token operator">=</span> <span class="token operator">&lt;</span>Component <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token keyword">const</span> domNodeElement <span class="token operator">=</span> <span class="token operator">&lt;</span>div <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><p>好的回答是：</p> <ul><li>元素是不可改变的纯对象，可以用来描述任何你想要渲染的 dom 节点或者组件。</li> <li>组件可以是一个函数或者是一个类，它接受 props 作为输入，以及输出一颗元素树。</li></ul> <h3 id="后缀增量运算符-i-和-前缀增量运算符-i-有什么区别？easy"><a href="#后缀增量运算符-i-和-前缀增量运算符-i-有什么区别？easy" aria-hidden="true" class="header-anchor">#</a> 后缀增量运算符 <code>i++</code> 和 前缀增量运算符<code>++i</code> 有什么区别？<sup style="color: green;">Easy</sup></h3> <p>两种方式都会使变量的值加1。不同的是它们赋值的时机。</p> <p>后缀增量运算符会在变量的值被增加前，给变量赋值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>
i<span class="token operator">++</span> <span class="token comment">// 0</span>
<span class="token comment">// i === 1</span>
</code></pre></div><p>前缀增量运算符会在变量的值被增加后，给变量赋值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>
<span class="token operator">++</span>i <span class="token comment">// 1</span>
<span class="token comment">// i === 1</span>
</code></pre></div><h3 id="promise-可以处于几种状态？easy"><a href="#promise-可以处于几种状态？easy" aria-hidden="true" class="header-anchor">#</a> Promise 可以处于几种状态？<sup style="color: green;">Easy</sup></h3> <p>一个 <code>Promise</code> 可以处于这些状态的其中之一：</p> <ul><li>pending: 初始状态，既没有完成也没有拒绝。</li> <li>fulfilled: 这个状态意味着操作已经成功完成。</li> <li>rejected: 这个状态意味着操作失败。</li></ul> <p>一个<code>pending</code>状态的 Promise 结果可以是完成附带一个值，或者是拒绝附带一个原因（错误）。当这些选择之一发生后，相关的处理程序会被这个 Promise 的 then 方法依次调用。</p> <h3 id="在-react-中，什么是一个有状态的组件？easy"><a href="#在-react-中，什么是一个有状态的组件？easy" aria-hidden="true" class="header-anchor">#</a> 在 React 中，什么是一个有状态的组件？<sup style="color: green;">Easy</sup></h3> <p>一个有状态的组件，它的行为依赖于它自身的状态。这意味着两个独立的组件实例，即使给予相同的 <code>props</code> 值，也不一定会给予相同的输出，它跟纯函数组件是不一样的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Stateful class component</span>
<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    thsi<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Stateful function component</span>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好的回答：</p> <ul><li>有状态的组件有内部依赖的状态。</li> <li>有状态的组件可以是类组件或者是使用了状态钩子的函数组件。</li> <li>有状态的组件有它们自身的状态，这些状态通过构造函数或 <code>useState()</code>初始化。</li></ul> <h3 id="什么是一个无状态的组件easy"><a href="#什么是一个无状态的组件easy" aria-hidden="true" class="header-anchor">#</a> 什么是一个无状态的组件<sup style="color: green;">Easy</sup></h3> <p>一个无状态组件是一个自身行为不依赖它自己的状态 <code>state</code>。无状态的组件可以是函数式组件或者是类组件。因为给无状态组件输入相同的 <code>props</code> 会保证得到相同的输出，所以它更容易被维护和测试。在你不需要使用生命周期钩子的时候，你应该优先考虑使用无状态的函数式组件。</p> <p>很高兴听到：</p> <ul><li>无状态组件和它们的状态是独立的。</li> <li>无状态组件可以是类组件或函数式组件。</li> <li>无状态组件完全没有 <code>this</code> 上下文。</li></ul> <h3 id="创建一个批处理函数，它返回该批中的能够按照食谱进行烹饪的最多次数。intermediate"><a href="#创建一个批处理函数，它返回该批中的能够按照食谱进行烹饪的最多次数。intermediate" aria-hidden="true" class="header-anchor">#</a> 创建一个批处理函数，它返回该批中的能够按照食谱进行烹饪的最多次数。<sup style="color: green;">INTERMEDIATE</sup></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 这个函数接收两个对象作为参数：第一个对象是食谱上要求的成分表，而第二个对象是当前能够使用的成分。每一种成分的值是代表它们的单位数量有多少。
 `batches(recipe, available)`
*/</span>

<span class="token comment">// 0 batches can be made</span>
<span class="token function">batches</span><span class="token punctuation">(</span>
  <span class="token punctuation">{</span> milk<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> butter<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span> flour<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> milk<span class="token punctuation">:</span> <span class="token number">132</span><span class="token punctuation">,</span> butter<span class="token punctuation">:</span> <span class="token number">48</span><span class="token punctuation">,</span> flour<span class="token punctuation">:</span> <span class="token number">51</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
<span class="token function">batches</span><span class="token punctuation">(</span>
  <span class="token punctuation">{</span> milk<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> flour<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> sugar<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> butter<span class="token punctuation">:</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> milk<span class="token punctuation">:</span> <span class="token number">1288</span><span class="token punctuation">,</span> flour<span class="token punctuation">:</span> <span class="token number">9</span><span class="token punctuation">,</span> sugar<span class="token punctuation">:</span> <span class="token number">95</span> <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token comment">// 1 batch can be made</span>
<span class="token function">batches</span><span class="token punctuation">(</span>
  <span class="token punctuation">{</span> milk<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> butter<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span> cheese<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> milk<span class="token punctuation">:</span> <span class="token number">198</span><span class="token punctuation">,</span> butter<span class="token punctuation">:</span> <span class="token number">52</span><span class="token punctuation">,</span> cheese<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>

<span class="token comment">// 2 batches can be made</span>
<span class="token function">batches</span><span class="token punctuation">(</span>
  <span class="token punctuation">{</span> milk<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> sugar<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span> butter<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span> milk<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> sugar<span class="token punctuation">:</span> <span class="token number">120</span><span class="token punctuation">,</span> butter<span class="token punctuation">:</span> <span class="token number">500</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre></div><p>我们必须保证可以获得食谱上所有的成分，并且数量上大于或等于成分要求的单位数量。**一旦缺失一种成分或数量上不足，我们都不能完成一次处理。**关键入手点在于这里，因此需要找出所有成分的比率值的最小值，才是整个能够按照食谱烹饪的最大值。</p> <p>第一步，使用<code>Object.keys()</code>以数组形式返回食谱的成分
然后使用 <code>Array.prototype.map()</code> 针对每种可以获得的成分的数量与菜谱上要求的成分数量作比例处理。只要有一个菜谱上要求的成分不可用，则比率值就等于 <code>NaN</code>。因此在这种情况下，需要使用逻辑与符号赋值为0。</p> <p>第二步，使用展开序列符<code>...</code>展开成分的比率值数组，传递给<code>Math.min()</code>函数获得最小的比率。最后传递这个比率给<code>Math.floor()</code>向上兼容取整获得整个批处理的最大数值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">batches</span> <span class="token operator">=</span> <span class="token punctuation">(</span>recipe<span class="token punctuation">,</span> available<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> 
  Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>
    Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token operator">...</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>recipe<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>k <span class="token operator">=&gt;</span> available<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">/</span> recipe<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
</code></pre></div> <h3 id="创建一个功能上相当于方法function-prototype-bind的单例函数-bindintermediate"><a href="#创建一个功能上相当于方法function-prototype-bind的单例函数-bindintermediate" aria-hidden="true" class="header-anchor">#</a> 创建一个功能上相当于方法<code>Function.prototype.bind</code>的单例函数 <code>bind</code><sup style="color: green;">INTERMEDIATE</sup></h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> boundExample <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>example<span class="token punctuation">,</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
boundExample<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span>b<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// logs { a: true }</span>
</code></pre></div><p>返回一个接收任意数量参数的函数，这些参数通过扩展运算符<code>...</code>来获取。从函数上可以看出，它返回通过<code>Function.prototype.apply</code>方法接收上下文 context 以及一个数组形式的参数来调用<code>fn</code>函数的结果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">bind</span> <span class="token operator">=</span> <span class="token punctuation">(</span>fn<span class="token punctuation">,</span> context<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="回调函数作为setstate-的一个参数的目的是什么？"><a href="#回调函数作为setstate-的一个参数的目的是什么？" aria-hidden="true" class="header-anchor">#</a> 回调函数作为<code>setState</code> 的一个参数的目的是什么？</h3> <p>当 <code>setState</code> 执行和组件渲染完成后，这个回调函数将会被调用。因为 <code>setState</code> 的执行是异步的，所以回调函数可以用在任何一次 post 操作。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">&quot;sudheer&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;The name has updated and component re-rendered&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>好的回答：</p> <ul><li>这个回调函数将会在 <code>setState</code>执行后被调用，并且可以用在任意一次的 post 动作。</li> <li>建议使用生命周期方法而不是这个 callback 回调函数。</li></ul> <h3 id="什么是回调？你可以举一个例子来说明吗？"><a href="#什么是回调？你可以举一个例子来说明吗？" aria-hidden="true" class="header-anchor">#</a> 什么是回调？你可以举一个例子来说明吗？</h3> <p>回调就是一个函数，作为一个参数被传入另外一个函数中，当一个事件发生后或者一个确定的任务执行后将会被执行，通常被用于异步的代码。回调函数除了可以被一段代码不久后调用外，它也可以在初始化时声明而不被调用。</p> <p>例如，事件监听器是异步回调的，只有当指定的事件发生时，它才会被执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;The user clicked on the page.&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>然后，回调也可以是同步的。下面的<code>map</code>函数接受一个回调函数，它会被同步调用在每一个循环的迭代（数组元素）。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">map</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n <span class="token operator">=&gt;</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// [2, 4, 6, 8, 10]</span>
</code></pre></div><p>很高兴听到</p> <ul><li>函数在 JavaScript 中是一类对象。</li> <li>回调 vs Promise</li></ul> <h3 id="在-javascript-中，你是怎么拷贝一个对象的？intermediate"><a href="#在-javascript-中，你是怎么拷贝一个对象的？intermediate" aria-hidden="true" class="header-anchor">#</a> 在 JavaScript 中，你是怎么拷贝一个对象的？<sup style="color: green;">INTERMEDIATE</sup></h3> <p>使用对象扩展运算符，可以把该对象自身可枚举的属性拷贝到新的对象中。这种方法实现的是浅拷贝。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> shallowClone <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>obj <span class="token punctuation">}</span>
</code></pre></div><p>使用这个方式不会拷贝原型链的东西。另外，嵌套的对象也不被拷贝，相反它们的引用地址会被拷贝，所以嵌套对象仍让跟原对象一样指向相同的对象。深拷贝是一种更复杂的拷贝方式，为了有效地拷贝可能会被嵌入到对象里的任何对象类型（日期、正则表达式、函数、Set等等）。</p> <p>其他可选的方案包括：</p> <ul><li><code>JSON.parse(JSON.stringify(obj))</code> 可以用来深拷贝一个简单的对象，但是它占用CPU资源，并且只能接受有效的 JSON 结构。（因此它排除了函数以及不允许循环引用。）</li> <li><code>Object.assign({}, obj)</code> 是另外一种可选方案。</li> <li><code>Object.keys(obj).reduce((acc, key) =&gt; (acc[key] = obj[key], acc), {})</code> 是另外一种比较冗余的选择，更深入地展示了深拷贝的概念。（这里初始值是一个空对象，之后进行一一拷贝）</li></ul> <p>很高兴能听到：</p> <ul><li>JavaScript 传递对象只是传递引用的地址，这意味着拷贝嵌套的对象只是拷贝它们的引用地址，而不是它们的字面量。</li> <li>相同的方法可以用来合并两个对象。</li></ul> <h3 id="在-javascript-中你是怎么比较两个对象是否相等？intermediate"><a href="#在-javascript-中你是怎么比较两个对象是否相等？intermediate" aria-hidden="true" class="header-anchor">#</a> 在 JavaScript 中你是怎么比较两个对象是否相等？<sup style="color: green;">INTERMEDIATE</sup></h3> <p>即使两个不同的对象具有相同的属性和值，当使用<code>==</code>或<code>===</code>时，它们也不能被认为相等。这是因为它们是通过引用地址（内存空间）来比较的，不像原始类型只是比较值的相等。</p> <p>为了测试两个对象是否在结构上相等，我们需要一个助手函数。它会遍历每个对象的自身属性，并测试它们的属性值是否相等，包括嵌套的对象。可选地，通过传递 <code>true</code> 作为第三个参数来决定对象的原型可能也需要被测试是否相等。</p> <p>注意：这种方案没有企图去测试除了纯对象、数组、函数、日期以及原始值类型之外的数据结构的相等。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isDeepEqual</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">,</span> testPrototypes <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj1 <span class="token operator">===</span> obj2<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 原始值</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj1 <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj2 <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> obj2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj1 <span class="token keyword">instanceof</span> <span class="token class-name">Date</span> <span class="token operator">&amp;&amp;</span> obj2 <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> obj1<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> obj2<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span> <span class="token operator">!==</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> obj1 <span class="token operator">!==</span> <span class="token string">&quot;object&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> prototypesAreEqual <span class="token operator">=</span> testPrototypes
    <span class="token operator">?</span> <span class="token function">isDeepEqual</span><span class="token punctuation">(</span>
        Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">,</span>
        Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token boolean">true</span>
    <span class="token punctuation">)</span>
    <span class="token punctuation">:</span> <span class="token boolean">true</span>
  <span class="token keyword">const</span> obj1Props <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> obj2Props <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    obj1Props<span class="token punctuation">.</span>length <span class="token operator">===</span> obj2Props<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> <span class="token comment">// 属性长度</span>
    prototypesAreEqual <span class="token operator">&amp;&amp;</span>  <span class="token comment">// 原型比较</span>
    obj1Props<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span>prop <span class="token operator">=&gt;</span> <span class="token function">isDeepEqual</span><span class="token punctuation">(</span>obj1<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">,</span> obj2<span class="token punctuation">[</span>prop<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 属性值比较</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>很高兴听到：</p> <ul><li>像字符串、数字这样的原始值类型比较的是它们的字面量值。</li> <li>相反，对象则通过比较它们的引用值（在内存中的地址）。</li></ul> <h3 id="什么是-cors？intermediate"><a href="#什么是-cors？intermediate" aria-hidden="true" class="header-anchor">#</a> 什么是 CORS？<sup style="color: green;">INTERMEDIATE</sup></h3> <p><code>Cross-Origin Resource Sharing</code>(跨域资源共享) 或 CORS 是一种机制，它使用额外的 HTTP 头部授予浏览器权限访问来自与 Web 应用不同域的服务器上的资源。</p> <p>一个跨域请求的例子是一个 web 应用的地址是 <code>http://mydomain.com</code>，然后使用 ajax 技术向 <code>http://yourdomain.com</code>请求数据。</p> <p>因为安全的原因，浏览器限制由 JavaScript 发起的跨域 HTTP 请求。<code>XMLHttpRequest</code> 和 <code>fetch</code> 遵循同源策略，这意味着一个 web
应用使用这些 API 只能从相同的域的可被访问的应用请求 HTTP 资源。</p> <p>很高兴听到：</p> <ul><li>CORS 行为不是一个 bug，它是一个安全机制来保护用户的信息。</li> <li>CORS 被设计用来在用户无意中从请求的合法网站到访问恶意网站时，阻止恶意网站去窃取用户的个信息或者是做一些违背用户的意愿的操作。</li></ul> <h3 id="dom-是什么-？"><a href="#dom-是什么-？" aria-hidden="true" class="header-anchor">#</a> DOM 是什么 ？</h3> <p>DOM（Document Object Model）是一个跨平台的 API，它可以把 HTML 和 XML 文档处理成一颗由节点组成的树。这些节点（如元素和文本节点）都是对象，可以被编程式地操作以及任何对于它们的视觉上的改变都会生动映射到文档中。在浏览中，这个 API 可以被 JavaScript 访问，可以使用 JavaScript 操作 DOM 节点的样式、内容、文档中的位置，或者是通过事件监听器进行交互。</p> <p>很高兴能听到：</p> <ul><li>DOM 被设计为独立于任何特定的编程语言，这样使得文档的结构性代表可以提供一个单一、一致的 API 访问。</li> <li>随着页面的加载，DOM 在浏览器中是逐渐地被构建出来的，这也是为什么要把脚本<code>script</code> 标签放到页面的底部、带有 <code>defer</code> 属性的 <code>&lt;head&gt;</code> 标签，或者放进 <code>DOMContentLoaded</code> 回调函数中避免出错。操作 DOM 的脚本应该在相关的 DOM 节点被构建出来才运行避免报错。</li> <li><code>domcument.getElementById()</code> 和 <code>document.querySelector()</code> 是常见的选择 DOM 节点的函数。</li> <li>通过给一个节点的 <code>innerHTML</code>属性设置一个新值及HTML 解析器运行字符串，提供了一种很简便的方式来添加动态的HTML内容进一个节点。</li></ul> <h3 id="事件委托是什么，为什么它是有用的呢？你可以用一个例子来说明怎么用吗？intermediate"><a href="#事件委托是什么，为什么它是有用的呢？你可以用一个例子来说明怎么用吗？intermediate" aria-hidden="true" class="header-anchor">#</a> 事件委托是什么，为什么它是有用的呢？你可以用一个例子来说明怎么用吗？<sup style="color: green;">INTERMEDIATE</sup></h3> <p>事件委托是一种委将事件委派到单个共同祖先元素的技术。由于事件冒泡，</p> 事件通过在每个祖先元素上逐步执任何处理程序“冒泡”到 DOM 树，直到可能正在监听它的根。
<p>DOM 事件提供通过初始化事件 <code>Event.target</code>发起事件的元素的有用信息，这样允许父元素处理行为，好像目标元素正在监听事件一样，而不是所有的父亲的子元素或者是父元素本身。</p> <p>它有两个优点：</p> <ul><li>它只需要注册一个元素的事件处理程序而不是成千上万个元素，从而提升了性能和减少内存的消耗。</li> <li>如果子元素是动态添加到父元素，则无需为它们注册新的事件侦听器。</li></ul> <p>而不是：</p> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">&quot;button&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>button <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> handleButtonClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>事件委托涉及使用条件判断来确保子目标匹配我们需要的元素：</p> <div class="language-js extra-class"><pre class="language-js"><code>document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">closest</span><span class="token punctuation">(</span><span class="token string">&quot;button&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleButtonClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>面试官想要听到的：</p> <ul><li>事件冒泡和事件捕获的区别。</li></ul> <h3 id="javascript-中的表达式和声明之间有什么区别？intermediate"><a href="#javascript-中的表达式和声明之间有什么区别？intermediate" aria-hidden="true" class="header-anchor">#</a> JavaScript 中的表达式和声明之间有什么区别？<sup style="color: green;">INTERMEDIATE</sup></h3> <p>在 JavaScript 中有两种主要的语法类别：表达式和声明。第三种是两者结合，称为表达式语句。它们可以粗略地概括为：
</p> <ul><li>表达式：生成一个值。</li> <li>语句：执行动作。</li> <li>表达式语句：生成一个值并执行一个动作。</li></ul> <p>一个普遍认可的规则：</p> <blockquote><p>如果你可以打印或者将其赋值给一个变量，那么它就是一个表达式。否则，它就是一个语句。</p></blockquote> <h4 id="声明"><a href="#声明" aria-hidden="true" class="header-anchor">#</a> 声明</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span>

<span class="token keyword">function</span> <span class="token function">declaration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div> <p>语句显示为可以执行某些动作但不会产生值的命令。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 将 x 指定为 y 的绝对值</span>
<span class="token keyword">var</span> x
<span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> y
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  x <span class="token operator">=</span> <span class="token operator">-</span>y
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的代码中唯一的表达式是 <code>y&gt;-=0</code>，它生成一个值为 <code>true</code> 或者 <code>false</code>的值。

代码的其他部分不会产生值。</p> <h4 id="表达式"><a href="#表达式" aria-hidden="true" class="header-anchor">#</a> 表达式</h4> <p>表达式产生一个值。因为编译器将它们替替换为要解析的值，所以可以传递给函数中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">5</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token comment">// =&gt; 10</span>
<span class="token function">lastCharacter</span><span class="token punctuation">(</span><span class="token string">&quot;input&quot;</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; &quot;t&quot;</span>
<span class="token boolean">true</span> <span class="token operator">===</span> <span class="token boolean">true</span> <span class="token comment">// =&gt; true</span>
</code></pre></div><h4 id="表达式语句"><a href="#表达式语句" aria-hidden="true" class="header-anchor">#</a> 表达式语句</h4> <p>以前使用条件操作符作为表达式使用的语句集的等效版本。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//  将 x 指定为 y 的绝对值</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> y <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token operator">?</span> y <span class="token punctuation">:</span> <span class="token operator">-</span>y
</code></pre></div> <p>这是既是表达式又是语句，因为我们将变量 <code>x</code>（声明）声明评估（表达式）。</p> <h4 id="面试官想听到"><a href="#面试官想听到" aria-hidden="true" class="header-anchor">#</a> 面试官想听到</h4> <ul><li>函数声明 vs 函数表达式。具体看这篇文<a href="https://github.com/Wscats/articles/issues/73" target="_blank" rel="noopener noreferrer">关于Javascript的函数声明和函数表达式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="参考资料"><a href="#参考资料" aria-hidden="true" class="header-anchor">#</a> 参考资料</h2> <ul><li><a href="https://muyiy.cn/question/" target="_blank" rel="noopener noreferrer">壹题汇总<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>《CSS 世界》</li></ul></div> <div class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">12/29/2019, 4:22:59 PM</span></div></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/language-learning/translator/skill.html">
          翻译技巧
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/language-learning/assets/js/12.aae45531.js" defer></script><script src="/language-learning/assets/js/app.18b27bb5.js" defer></script>
  </body>
</html>
